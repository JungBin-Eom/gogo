# 에러 처리

책 본편에서는 에러 처리를 많이 다루지 못했습니다. 그 때는 에러 처리에 대한
경험이 부족하기도 했고, Go 언어 커뮤니티 전체에서도 에러 처리에 대하여 경험이
부족했습니다. 여기서 약간이나마 내용을 더 보충하여 추가하고자 합니다.

## 과거의 다양한 에러 처리 방법
 
 옛날부터 에러 처리는 다양한 방법을 이용하였습니다. 많은 언어들에서 함수가 단
 하나의 값만 반환할 수 있는 경우가 많습니다. 따라서 여러가지 방법을
 이용했습니다.

사용되지 않는 특정 결과 값을 에러 코드로 사용하는 경우가 있습니다. Go에서는
`strings.Index()` 등과 같은 함수들이 사용합니다. 엄밀하게 말하면 부분 문자열을
못 찾은 경우가 에러 상황은 아니라 생각하지만 어쨌든 못 찾은 경우에는 -1 값을
반환합니다. 이처럼 만약에 음수 범위의 값이 사용되지 않는다면 -1, -2, -3 등을
각기 다른 에러 코드를 표현하는데 사용할 수 있습니다. 물론 이것이 항상 가능한
것은 아닙니다. 맵에서 값을 얻어오는 함수 같은 것은 값을 찾지 못했을 때에 반환할
수 있는 값이 없습니다. 만약에 빈 문자열이 정상적으로 결과 값이 나올 수 없다면
이것을 이용할 수 있고, 그것도 아니라면 가장 크거나 작은 정수 값 등을 사용할 수
있습니다.

위의 방식이 에러를 결과 값의 영역 내에서 정의하여 사용하는, 즉 에러와 결과 값을
하나의 도메인에서 서로 섞는 방법이라면 에러와 결과 값을 구분하는 방법도 생각해
볼 수 있습니다. 함수가 에러 코드를 반환하는 경우입니다. 에러 코드를 반환하는
경우에는 정상적인 경우에는 정상 코드를 반환하고 에러가 발생했을 때는 해당 에러에
맞는 코드를 반환합니다. 문제는 결과 반환입니다. 에러 코드만 반환이 되었지 결과는
반환 값으로 넘겨 줄 수가 없었습니다. 이 경우에 참조에 의한 호출을 지원하는
언어에서는 특정 파라미터의 값을 변경시킴으로써 결과를 출력할 수 있었습니다.
포인터를 지원하는 언어에서는 포인터를 이용하여 결과를 반환했습니다. Go 언어에서
`fmt.Scanf` 혹은 `Unmarshal` 함수들 중에서 포인터를 넘겨주어서 결과를 얻어내는
경우가 있습니다. 여러 값을 반환할 수 있는 Go에서 흔한 경우는 아니지만 주로
반환될 결과의 타입을 알 수 없기에 제네릭 기능이 없어서 선택하는 경우가 많습니다.

정반대로 결과 값을 반환하고 에러 변수를 참조나 포인터로 넘겨서 받는 경우도
있습니다. 에러를 받기 위한 변수를 선언하고 넘겨주는 것이 번거롭다고 생각한다면
에러 변수를 넘기지 않는 대신에 에러 코드를 글로벌 변수에 할당하거나 하는 식으로
반환하는 경우도 있었습니다. 다만 이런 방식은 멀티 쓰레드에서는 쓸 수가 없습니다.

결과 값과 에러를 모두 반환하는 방법을 쓸 수 있습니다. 하나의 값만을 반환할 수
있는 언어에서는 값과 에러 코드를 구조체 등을 이용하여 묶어서 반환하고, 받는
쪽에서는 에러 코드를 확인하고 결과 값을 사용할 수 있습니다. 여기서
`ValueOrError`, `Option` 같은 구조나 타입 시스템을 이용하는 방법들이 있고, 패턴
매치를 하기도 하며, 모나드와도 관련이 있습니다. 자바스크립트 등의 언어에서는
Promise를 활용하기도 합니다. Go 언어는 여러 값을 반환할 수 있으므로 결과 값과
에러 값 모두를 따로 반환할 수 있습니다. 이것에 대해서는 조금 뒤에 다시
논하겠습니다.

아예 콜백을 이용하여 에러 핸들러를 넘겨주는 방식으로 에러 처리를 할 수도
있습니다. Go에서 함수는 일등 시민이므로 onError 같은 함수를 클로저로 넘겨서 에러
처리를 할 수도 있을 것입니다.

에러를 값으로 취급하지 않고 예외를 던지고 받는 방식을 이용할 수도 있습니다.
자바와 파이썬을 비롯한 많은 언어에서 사용하는 방법인데, 에러를 어떻게 처리할지
모르는 문맥에서는 에러 처리 코드를 쓰지 않아서 코드를 깔끔해 보이게 만드는
장점이 있습니다. 예외를 처리하지 않으면 호출 스택을 타고 올라가면서 전파가 되고
이것을 받아서 처리할 수 있는 곳에서 핸들링을 해 줍니다.

Go 언어는 여러 값을 반환할 수 있으므로 결과 값과 에러 값을 동시에 반환할 수
있습니다. 따라서 위에서 살펴본 결과 값과 에러 값을 묶어서 반환하는 것과 비슷한
점이 있습니다. 주로 에러 값을 확인하고 처리하고 에러가 없으면 값을 이용하는
패턴을 사용합니다. 패닉은 에러 상황에서 사용되기보다는 프로그래밍 실수로 인하여
발생하는 경우에 주로 사용합니다.

물론 제네릭이 없다 뿐이지 언어가 지원하는 기능을 이용하여 다른 방법으로 에러를
처리할 수도 있지만 기본적으로 에러 값을 반환하는 방식으로 처리합니다.

## 에러 처리

반환 받은 에러를 if 문을 활용하여 에러가 발생했는지 확인할 수 있습니다. `error`
는 단지 `Error()` 메서드를 구현하는 인터페이스에 불과합니다. 이 메서드가
호출되면 에러 문자열이 반환됩니다.

에러를 복구할 수 있을 때에는 에러를 반환하지 않고 복구할 수 있습니다. 예를
들어서 현재 접속이 너무 많아서 다시 걸어 달라는 에러가 발생하면 잠시 기다렸다가
다시 시도할 수 있습니다.

현재 함수에서는 에러를 처리할 방법이 없는 경우에는 그 에러를 반환하게 됩니다.
여기서 에러를 그대로 `return error` 하여 반환하면 문제가 있습니다. 반환 받은
함수 역시 어떻게 처리할지 모르고 해서 몇 차례 거슬러 올라가게 되면 이 에러가
어디서 왔는지 알기 어렵다는 문제가 있습니다. 이 상태에서 에러를 출력하면 에러를
출력하는 함수 입장에서는 굉장히 뜬금없는 메시지가 보일 수 있습니다.

예를 들어서 요청받은 글을 반환하는 함수가 있다고 하면, 해당 글을 불러오는 함수를
호출할 것이고, 이 함수는 파일 시스템에서 파일 경로를 찾아서 내용을 가져온다고
합시다. 파일을 여는 함수를 호출하였는데, 이 함수는 요청 받은 글을 가져오기
위하여 파일을 여는지는 알 턱이 없습니다. 따라서 그 함수의 문맥 내에서는 적절한
메시지인 "파일을 찾을 수 없습니다" 라는 에러 메시지를 반환하게 됩니다. 그러면 그
에러를 받은 함수는 다시 그 값을 그대로 반환하여 몇 차례 더 올라갑니다. 이제
요청받은 글을 반환하는 함수를 호출했는데 에러 메시지는 달랑 "파일을 찾을 수
없습니다"가 됩니다. 눈치 100단이라 무슨 일이 일어났는지 빤히 알겠다고요? 물론
글이 저장된 파일이 없는 모양이라고 생각했지만 그 파일은 있는 파일이었습니다.
알고 보니 글을 가져오라는 요청을 받고 글을 살펴보니 비밀글이어서 사용자 ID를
체크하는 함수에서 해당 ID의 이름으로 된 파일을 찾았는데, 그 파일이 없었던
겁니다. 즉, 이 경우에는 "해당 글에 접근 권한이 없습니다" 라는 메시지를
출력시켜야 하는 경우입니다.

한 가지 방법은 에러에 추가 메시지를 기입하는 것입니다.

```go
return fmt.Errorf("authentication failed: %v", err)
```

이러면 몇 번 타고 올라가면 메시지가 `fetching post failed: no permission to read
the post: authentication failed: file not found`와 같이 됩니다. 여기서 콜론(:)은
"왜냐하면"의 의미라고 보시면 되겠습니다.

그런데 이 방식에도 문제가 있습니다. 이 에러는 메시지를 출력하기에는 좋지만, 어떤
소스 코드 파일의 몇 번째 줄에서 이 에러가 발생했는지 따라가기가 어렵습니다.
게다가 괜히 도움을 준다고 메시지를 첨부했는데, 원래 에러에는 접근할 수 있는
방법이 없어지게 됩니다.

조금 더 자세한 예를 들겠습니다. 이번에는 문서를 HTTP로 접근해서 가져오는데,
이용자가 많은 경우에는 잠시 후에 다시 시도하라는 에러를 반환합니다. 이 에러가
`ErrTemporarilyBusy`라고 가정합니다. 이제 이 함수를 직접 쓰는 함수는 이것이
`ErrTemporarilyBusy`인지 확인하고 맞다면 다시 재시도를 합니다. 그러나 만약 이
함수를 직접 쓰지 않고 다른 함수가 이 함수를 감쌌다고 합시다. 이 함수가 문맥을
추가하기 위해 더 상세한 정보를 추가하는 순간, 이 에러는 `ErrTemporarilyBusy`
에러와는 다르게 됩니다.

Go 2의 에러 값 추가 사항으로 논의되고 있는 것은 `%w`라는 형식을 추가하는 것입니다.

```go
return fmt.Errorf("authentication failed: %w", err)
```

이렇게 하면 v만 w로 바뀌었을 뿐인데 반환되는 에러는 해당 에러를 감싼 에러가
됩니다. 이 에러를 `Unwrap()` 하여 한 꺼풀씩 벗길 수 있습니다. 이렇게 한 꺼풀씩
벗겨 가며 에러를 체크하는 것을 하는 함수가 `errors.Is()` 함수가 됩니다.

이 글을 쓰는 현재는 아직 표준 라이브러리에 포함되지 않았기 때문에 `xerrors`라는
패키지로 제공됩니다. 이렇게 에러를 감쌀 경우에는 `%+v` 형식으로 출력하면 에러를
감싼 곳의 코드 위치가 모두 출력되어서 어디서 에러가 발생하였는지 추적하는 것이
매우 편리합니다.

여기에 포함된 코드 예제를 참조하시기 바랍니다.

에러 값이 아니라 에러의 타입을 체크할 때에는 `errors.As()` 함수를 이용하면
됩니다. 아직 관련 코드 예제는 작성되지 않았습니다.
